#include <stdio.h>
#include <time.h>
#include <stdlib.h>

/*
stastic 关键字

* 参考 ：https://www.runoob.com/w3cnote/cpp-static-usage.html

* 静态函数：只能在当前文件使用这个函数，出了这个文件就不能使用
* 静态变量：

* static 修饰符
    * 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
    * static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
    * static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。
    * static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
    * 不想被释放的时候，可以使用 static 修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
    * 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

* 静态全局变量有以下特点：
    * 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
    * 未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
    * 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
    优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

* 全局变量和全局静态变量的区别
    * 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
    * 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

* 关于空间大小的问题
    * 直接定义一个数组，如a[SIZE];这个是分配的静态空间，在栈上（局部变量）或全局静态区（全局变量）上分配的，一般栈的内存是1M到2M，
      所以静态分配的空间不能太大，比如如果定义a[1024*1024];运行时就会报”段错误“，遇到要申请大的空间时，就需要动态申请。
    * 函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小；
    * 全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为2G，所以能够开的很大；
    * 而 malloc、new 出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小；

*/


int k1 = 1;
int k2;
static int k3 = 2;
static int k4;

int main()
{
    static int m1 = 2, m2;
    int i = 1;
    char *p;
    char str[10] = "hello";
    char *q = "hello";
    p = (char *)malloc(100);
    free(p);
    printf("栈区-变量地址    i：%p\n", &i);
    printf("栈区-变量地址   p：%p\n", &p);
    printf("栈区-变量地址 str：%p\n", str);
    printf("栈区-变量地址   q：%p\n", &q);
    printf("堆区地址-动态申请：%p\n", p);

    printf("全局外部有初值 k1：%p\n", &k1);
    printf("   外部无初值 k2：%p\n", &k2);
    printf("静态外部有初值 k3：%p\n", &k3);
    printf("   外静无初值 k4：%p\n", &k4);
    printf("  内静态有初值 m1：%p\n", &m1);
    printf("  内静态无初值 m2：%p\n", &m2);
    printf("    文字常量地址：%p, %s\n", q, q);
    printf("      程序区地址：%p\n", &main);
    return 0;
}