# 说明

* 一个进程里面可以有多个线程
* 进程只能使用进程之间的通信(IPC)，而不能直接共享信息
* 运行在同一个进程中的线程，可以共享运行环境
* 单核 CPU 不能真正的并发，每个线程被安排成只运行一小会

* 设置 setDaemon(False), 在进程退出时，需要等待这个进程完成
* 设置 setDaemon(True), 在进程退出时，不需要等待这个进程完成
* 新的子线程会继承父线程的 daemon 属性

*  锁有两种状态——锁定和未锁定。每当一个线程比如"set"要访问共享数据时，必须先获得锁定；
如果已经有别的线程比如"print"获得锁定了，那么就让线程"set"暂停，也就是同步阻塞；
等到线程"print"访问完毕，释放锁以后，再让线程"set"继续。

* 如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。

* 所有线程创建之后再一起调用 start 函数启动，而不是每创建一个线程就启动，然后对每个线程调用 join 函数，等待子线程结束

* 如果多个线程修改同一个数据，可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步

* 【同步阻塞】 : 当一个线程要访问共享数据时，必须先获得锁定，如果已经有别的线程获得锁定了，就让线程停止，这就是同步阻塞，等到线程
访问结束，释放锁以后，再让线程开始

* 多线程的缺点就是，任何一个线程挂掉都可能导致整个进程崩溃，因为所有线程贡献进程的内存（存在稳定性的问题）
* 多线程的优点是能快一点
* 多进程的确定就是创建进程的代价比较大，特别是在 windows 系统下面
* 多进程的优点就是稳定性高，一个进程崩溃不会影响主程序，和其他进程

* 操作系统在切换进程或者线程时 需要先保存当前执行的现场环境（CPU 寄存器状态，内存页等），然后把新任务的执行环境准备好，才能开始执行
* 如果有几千个任务同时进行，操作系统可能主要忙着切换任务，根本没多少时间执行任务，这种情况最常见的就是硬盘狂响，点击窗口没有
反应，这时系统处于假死状态

* 计算密集型： 需要大量计算，消耗 CPU 资源
* IO 密集型： 设计网络磁盘 IO 的任务，CPU 消耗很少，任务的绝大部分时间都在等待 IO 操作完成
* IO ：input/output
* 异步IO : 使用了异步IO，在发起IO请求到实际使用数据这段时间 内，程序还可以继续做其他事情
* Python 比较适合做 IO 密集型的操作，而不是计算密集型的操作

* Python解释器是单线程的，还有使用多线程的必要吗？
* 多线程最开始不是用来解决多核利用率的问题的，而是用来解决 IO 占用 CPU 闲置时间的问题，如果运行瓶颈不是在计算，而是在 IO 使用
多线程显然更加合算，

### threading 的使用

Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。

threading 模块提供的其他方法：

* threading.currentThread(): 返回当前的线程变量。
* threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
* threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。

除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:

* run(): 用以表示线程活动的方法。
* start():启动线程活动。
* join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
* isAlive(): 返回线程是否活动的。
* getName(): 返回线程名。
* setName(): 设置线程名。

### CPU 密集型和 IO 密集型各是哪些操作

#### IO 密集型
* 打印到屏幕
* 读取键盘输入
* 打开关闭和操作文件

 
